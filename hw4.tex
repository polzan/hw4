\documentclass[a4paper,oneside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[margin=2.54cm]{geometry}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{graphicx}
%\usepackage{xr}
\usepackage{subcaption}
%\usepackage{changepage}
\usepackage[section]{placeins}
\usepackage{hyperref}

%\strictpagecheck
%\externaldocument{hw4_code}

\definecolor{matlabgreen}{RGB}{28,172,0}
\definecolor{matlablilas}{RGB}{170,55,241}

\newcommand{\includecode}[1]{\lstinputlisting[caption={\ttfamily #1.m},label={lst:#1}]{matlab/#1.m}}
\newcommand{\inlinecode}[1]{\lstinline[basicstyle=\ttfamily,keywordstyle={},stringstyle={},commentstyle={\itshape}]{#1}}

\renewcommand{\vec}[1]{\underline{#1}}
\renewcommand{\Re}[1]{\operatorname{Re}\left[#1\right]}
\renewcommand{\Im}[1]{\operatorname{Im}\left[#1\right]}
\newcommand{\E}[1]{\operatorname{E}\left[#1\right]}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\F}[1]{\operatorname{\mathcal{F}}\left[#1\right]}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\Prob}[1]{\operatorname{P}\left[#1\right]}
\newcommand{\ProbC}[2]{\operatorname{P}\left[#1\middle|#2\right]}
\newcommand{\ind}[1]{\operatorname{\mathbbm{1}}\left\{#1\right\}}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}
\newcommand{\distr}[0]{\sim}
\newcommand{\unif}[1]{\mathcal{U}_{#1}}

\newcommand{\vsigma}[0]{\vec{\sigma}}

\newcolumntype{L}{>{$}l<{$}}
\newcolumntype{R}{>{$}r<{$}}
\newcolumntype{C}{>{$}c<{$}}

\author{Enrico Polo \and Riccardo Zanol}
\title{Homework 4}

\begin{document}
\lstset{
  language=Matlab,
  basicstyle={\ttfamily \footnotesize},
  breaklines=true,
  morekeywords={true,false,warning,xlim,ylim},
  keywordstyle=\color{blue},
  stringstyle=\color{matlablilas},
  commentstyle={\color{matlabgreen} \itshape},
  numberstyle={\ttfamily \tiny},
  frame=leftline,
  showstringspaces=false,
  numbers=left,
  upquote=true,
}
\maketitle
\section{Bit error probability comparison}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{matlab/pbits_uncoded}
  \caption{$P_{bit}$ comparison while transmitting uncoded bits}
  \label{plot:uncoded}
\end{figure}
In Fig.~\ref{plot:uncoded} we report the bit error probabilities that
we obtain by simulating the single carrier (section~\ref{sec:dfe}) and
the OFDM (section~\ref{sec:ofdm}) systems for various values of the
SNR. Together with these two systems we plot the same bound
simulated in HW3 that we obtain with an AWGN channel:
\begin{align}
  y_k &= a_k + w_k \\
  w_k & \distr \mathcal{CN}(0, \sigma^2_w) \\
  \sigma^2_w &= \frac{\sigma^2_a}{\Gamma} \\
  \sigma^2_a &= 2 .
\end{align}

For each point of the plot we generate 3 millions of uniformly
distributed bits and map them into symbols from the same constellation
of HW3, associating the even bits to the real part and the odd bits
to the imaginary part
\begin{align}
  \mathcal{A} &= \left\{ 1+j, -1+j, -1-j, 1-j \right\} \\
  b_{2l}  & \leftrightarrow \Re{a_k} \\
  b_{2l+1}  & \leftrightarrow \Im{a_k}
\end{align}
and then we simulate the transmission of these symbols through the
AWGN, OFDM and DFE systems. The received signals $y_k$ are then passed
to a threshold detector to obtain the bits.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{matlab/pbits_coded}
  \caption{$P_{bit}$ comparison while transmitting LDPC-coded bits}
  \label{plot:coded}
\end{figure}
In Fig.~\ref{plot:coded} there are the bit error probabilities of the
same three systems when the input bits are channel-coded before being
mapped to symbols.

In this case we also generate 3 millions (rounded up to a multiple of
the LDPC block size) of uniformly distributed bits for each point of
the plot, but they are coded by an LDPC encoder, that uses the default
settings of Matlab, and then reordered by an interleaver that writes
the input bits by columns in a $31\times35$ matrix and reads them by
row. The resulting bits $c'_p$ are then mapped into symbols like in
the uncoded case and sent through each one of the three systems.  This
time, instead of using a threshold detector, we compute the
log-likelihood ratio of the received bits from the real and imaginary
parts of $y_k$
\begin{align}
  l'_{2k} &= \frac{2\Re{y_k}}{\sigma^2_w/2}
  \label{eq:llr_even} \\
  l'_{2k+1} &= \frac{2\Im{y_k}}{\sigma^2_w/2}
  \label{eq:llr_odd}
\end{align}
with a noise power $\sigma^2_w$ that depends on which system we are
simulating. The LLR $l'_p$ is then deinterlaced by writing its samples
by row in a $31\times35$ matrix and reading them by column and it is
then passed to the LDPC decoder that outputs the detected bits
$\hat{b}_l$.

\section{DFE}
\label{sec:dfe}
The configuration of the SC scheme is the same of the point b) of the previous homework as required. The parameter we used are 
\begin{align}
  M_1 &= 3 \\
    M_2 &= 2 \\
    D &= 1 \\
    \overline{t_0} &= 19 ,
\end{align}
where M1 is the length of the feed-forward filter $c$, M2 is the length of the feedback filter $b$ and $D$ is the delay introduced by the $c$ filter.
As suggested, we cut a little bit more the channel impulse response, whose behaviour is shown in Fig.~\ref{plot:qc}. So we have also to adapt the optimal value of $\Bar{t_0}$ that now is $\Bar{t_0} = 19$ (number of samples at $T_c$), in order to sample in the peak of the overall impulse response before the sampler $q_c * g_M$.

In the case where we encode the bits before modulating we use
equations (\ref{eq:llr_even}) and (\ref{eq:llr_odd}) to compute the
LLR at the receiver side, where the noise powers are
\begin{equation}
  \sigma^2_I = \sigma^2_Q = \frac{\sigma^2_w}{2} = \frac{\sigma^2_a E_{q_c}}{2\Gamma} .
\end{equation}

\section{OFDM}
\label{sec:ofdm}
The OFDM system takes as input the symbol sequence we want to transmit $a_k$ and splits it into $M-N_{vir}$ subsequences that corresponds to the number of subchannels available for transmitting data. In fact we avoid trasmitting (we send only zeros) across the subchannels in the interval $[\frac{M}{2}-\frac{N_{vir}}{2},\frac{M}{2}+\frac{N_{vir}}{2}]$ in order to avoid having to use a pair of transmit and receive filters with very narrow transition bands.
We select $N_{vir} = 48$ in order to find a compromise betweeen achieving good performances and don't waste too much bandwidth. With this choise we waste about $ 10\% $ of the transmitting subchannels but, on the oder hand, we reach a reasonable $ P_{bit} $.
Then for every subsequence $a_k[i], i = 1,2...M$ we compute the IDFT, obtaining $A_k[i] = IDFT[a_k[i]]$, and we add a prefix in order to guarantee the orthogonality between the various subchannels. To do this we select $N_{px} = 12$ that corresponds to the length of the non zero coefficient of equivalent channel impulse response $h(mT_{OFDM}) = g_c(t_0+ mT_{OFDM})$, where $g_c = g_{rcos}*q_c*g_{rcos}(nT_c)$, as can be seen in Fig. ~\ref{plot:h} and 
\begin{align*}
T_{OFDM} = \frac{T_{block}}{M+N_{px}}
\end{align*} 
that is the symbol period after the parallel to series conversion ($T_{block}$ is the period to trasmit an entire $A_k[i]$ sequence).
In fact finally we convert the parallel of the $A_k[i]$ blocks in their series (block by bock) and trasmit the obtained symbol sequence $s_k$ through the channel.
\newline The channel model we have to implement is composed by 3 blocks:
\begin{itemize}
\item trasmitter filter
\item receiver filter
\item channel
\end{itemize} 
The trasmitter and receiver filters $g_{rcos}(nT_c)$ impulse response is the same and it's reportend in Fig. ~\ref{plot:g_rcos}. In Fig. ~\ref{plot:g_rcos_freqz} we have indeed the frequqncy responce of the two filters, in which we can see the low-pass behaviour, with a cut-off frequency of about 0.125.For these filters we choose a length of 40 taps to have a good accuracy. With reguard to the channel, the impulse response $q_c$ it's shown in Fig. ~\ref{plot:qc}, while the frequency response it's in Fig. ~\ref{plot:qc_freqz}.
To complete the desctiption of the channel behaviour we add before the receiver filter we the complex gaussian noise that affects our transmission. We estimate the corresponding power $\sigma_{\omega}^2$ by using the information of our target SNR ($\Gamma$) through the relation:

\begin{align*}
\sigma_{\omega}^2 = \frac{(M-N_{vir})}{M^2}\frac{\sigma_{a}^2 E_{g_{rcos},qc}}{\Gamma}
\label{eq:var_OFDM}
\end{align*}

where $E_{g_{rcos},qc}$ is the energy of the series between the transmitter filter and the channel $g_{rcos,qc}(nT_c) = g_{rcos}*q_c(nT_c)$ and $\sigma_a^2 = 2$ is the power of the transmitted constallation.
\newline At the receiver side after filtering with $g_c = g_{rcos}$ we sample the signal in the instants $t_0 + kT_{OFDM}$ where we choose $\hat{t_0} = \frac{t_0}{T_c} = 27$ in order to start sampling from the first non zero coefficient of the equivalent channel impulse response $h$ (Fig. ~\ref{plot:h}). After sampling we decompose the received sequence $r_k$ among the $M$ subchannels obtaining $\hat{A}_k[i], i = 1,2,..M$ (that are the same block as before after crossing the channel), we remove the $N_{px}$ prefix on each block and we compute the DFT obtaining for every block obtaining the output signals $y_k[i] = DFT[\hat{A}_k[i]]$. We equalize each block by using ??????????? Finally we convert the parallel of the $y_k[i]$ into their series (block by block as in the transmitter) and use the received sequence $y_k$ to estimate the transmitted symbols. 
\newline In the case of the uncoded bits we use a simple threshold detector, otherwise we use the relations (\ref{eq:llr_even}) and (\ref{eq:llr_odd}) to compute the LLR with the $\sigma^2_w$ computed by using (\ref{eq:var_OFDM}).

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/qc}
  \caption{Channel impulse response}
  \label{plot:qc}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/g_rcos}
  \caption{Transmitter/receiver filter impulse response}
  \label{plot:g_rcos}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/gc}
  \caption{Global impulse response before receiver sampler}
  \label{plot:gc}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/h}
  \caption{Equivalent channel impulse response}
  \label{plot:h}
\end{figure}


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/qc_freqz}
  \caption{Channel frequency response}
  \label{plot:qc_freqz}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/g_rcos_freqz}
  \caption{Transmitter/receiver filter frequency response}
  \label{plot:g_rcos_freqz}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/gc_dft}
  \caption{M-sample DFT of the overall response $g_c$}
  \label{plot:gc_dft}
\end{figure}


\end{document}
