\documentclass[a4paper,oneside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[margin=2.54cm]{geometry}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{graphicx}
%\usepackage{xr}
\usepackage{subcaption}
%\usepackage{changepage}
\usepackage[section]{placeins}
\usepackage{hyperref}

%\strictpagecheck
%\externaldocument{hw4_code}

\definecolor{matlabgreen}{RGB}{28,172,0}
\definecolor{matlablilas}{RGB}{170,55,241}

\newcommand{\includecode}[1]{\lstinputlisting[caption={\ttfamily #1.m},label={lst:#1}]{matlab/#1.m}}
\newcommand{\inlinecode}[1]{\lstinline[basicstyle=\ttfamily,keywordstyle={},stringstyle={},commentstyle={\itshape}]{#1}}

\renewcommand{\vec}[1]{\underline{#1}}
\renewcommand{\Re}[1]{\operatorname{Re}\left[#1\right]}
\renewcommand{\Im}[1]{\operatorname{Im}\left[#1\right]}
\newcommand{\E}[1]{\operatorname{E}\left[#1\right]}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\F}[1]{\operatorname{\mathcal{F}}\left[#1\right]}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\Prob}[1]{\operatorname{P}\left[#1\right]}
\newcommand{\ProbC}[2]{\operatorname{P}\left[#1\middle|#2\right]}
\newcommand{\ind}[1]{\operatorname{\mathbbm{1}}\left\{#1\right\}}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}
\newcommand{\distr}[0]{\sim}
\newcommand{\unif}[1]{\mathcal{U}_{#1}}

\newcommand{\vsigma}[0]{\vec{\sigma}}

\newcolumntype{L}{>{$}l<{$}}
\newcolumntype{R}{>{$}r<{$}}
\newcolumntype{C}{>{$}c<{$}}

\author{Enrico Polo \and Riccardo Zanol}
\title{Homework 4}

\begin{document}
\lstset{
  language=Matlab,
  basicstyle={\ttfamily \footnotesize},
  breaklines=true,
  morekeywords={true,false,warning,xlim,ylim},
  keywordstyle=\color{blue},
  stringstyle=\color{matlablilas},
  commentstyle={\color{matlabgreen} \itshape},
  numberstyle={\ttfamily \tiny},
  frame=leftline,
  showstringspaces=false,
  numbers=left,
  upquote=true,
}
\maketitle
\section{Bit error probability comparison}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{matlab/pbits_uncoded}
  \caption{$P_{bit}$ comparison while transmitting uncoded bits}
  \label{plot:uncoded}
\end{figure}
In Fig.~\ref{plot:uncoded} we report the bit error probabilities that
we obtain by simulating the single carrier (section~\ref{sec:dfe}) and
the OFDM (section~\ref{sec:ofdm}) systems for various values of the
SNR. Together with these two systems we plot the same bound
simulated in HW3 that we obtain with an AWGN channel:
\begin{align}
  y_k &= a_k + w_k \\
  w_k & \distr \mathcal{CN}(0, \sigma^2_w) \\
  \sigma^2_w &= \frac{\sigma^2_a}{\Gamma} \\
  \sigma^2_a &= 2 .
\end{align}

For each point of the plot we generate 3 millions of uniformly
distributed bits and map them into symbols from the same constellation
of HW3, associating the even bits to the real part and the odd bits
to the imaginary part
\begin{align}
  \mathcal{A} &= \left\{ 1+j, -1+j, -1-j, 1-j \right\} \\
  b_{2l}  & \leftrightarrow \Re{a_k} \\
  b_{2l+1}  & \leftrightarrow \Im{a_k}
\end{align}
and then we simulate the transmission of these symbols through the
AWGN, OFDM and DFE systems. The received signals $y_k$ are then passed
to a threshold detector to obtain the bits.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{matlab/pbits_coded}
  \caption{$P_{bit}$ comparison while transmitting LDPC-coded bits}
  \label{plot:coded}
\end{figure}
In Fig.~\ref{plot:coded} there are the bit error probabilities of the
same three systems when the input bits are channel-coded before being
mapped to symbols.

In this case we also generate 3 millions (rounded up to a multiple of
the LDPC block size) of uniformly distributed bits for each point of
the plot, but they are coded by an LDPC encoder, that uses the default
settings of Matlab, and then reordered by an interleaver that writes
the input bits by columns in a $31\times35$ matrix and reads them by
row. The resulting bits $c'_p$ are then mapped into symbols like in
the uncoded case and sent through each one of the three systems.  This
time, instead of using a threshold detector, we compute the
log-likelihood ratio of the received bits from the real and imaginary
parts of $y_k$
\begin{align}
  l'_{2k} &= \frac{2\Re{y_k}}{\sigma^2_w/2}
  \label{eq:llr_even} \\
  l'_{2k+1} &= \frac{2\Im{y_k}}{\sigma^2_w/2}
  \label{eq:llr_odd}
\end{align}
with a noise power $\sigma^2_w$ that depends on which system we are
simulating. The LLR $l'_p$ is then deinterlaced by writing its samples
by row in a $31\times35$ matrix and reading them by column and it is
then passed to the LDPC decoder that outputs the detected bits
$\hat{b}_l$.

\section{DFE}
\label{sec:dfe}
The configuration of the SC scheme is the same of the point b) of the previous homework as required. The parameter we used were:
\begin{itemize}
\item M1 = 3;
\item  M2 = 2;
\item D = 1.
\end{itemize}
M1 is the length of the feed-forward filter $c$, M2 is the length of the feedback filter $b$ and $D$ is the delay introduced by the $c$ filter.
As suggested, we cut a little bit more the channel impulse response, whose behaviour is shown in Fig.~\ref{plot:qc}. So we have also to adapt the optimal value of $\Bar{t_0}$ that now is $\Bar{t_0} = 19$ (number of samples at $T_c$), in order to sample in the peak of the overall impulse response before the sampler $q_c * g_M$.

In the coded case we use equations (\ref{eq:llr_even}) and
(\ref{eq:llr_odd}) to compute the LLR where the noise power
$\sigma^2_w$ is the power of the noise that we add after the channel
\begin{align}
  \sigma^2_w &= \frac{\sigma^2_a E_{q_c}}{\Gamma} .
\end{align}

\section{OFDM}
\label{sec:ofdm}
The OFDM system take as input the symbol sequence we want to transmit $a_k$ and split it into $M-N_{vir}$ subsequences that corresponds to the number of subchannels available for transmitting data. In fact we avoid trasmitting (sending all zeros) across the subchannels in the interval $[\frac{M}{2}-N_{vir}/2,\frac{M}{2}+\frac{N_{vir}}{2}]$ ???why????.
We select $N_{vir} = 48$ in order to find a compromise betweeen achieving good performances and don't waste too much channel capacity. With this choise we waste about $ 10\% $ of the transmitting subchannels but, on the oder hand, we reach a reasonable $ P_{bit} $.
Then for every subsequence $\hat{a}_k[i], i = 1,2...M$ we compute the IDFT, obtaining $A_k[i] = IDFT[a_k[i]]$, and we add a prefix in order to guarantee the orthogonality between the various subchannels. To do this we select $N_{px} = 12$ that corresponds to the length of the non zero coefficient of equivalent channel impulse response $h(mT_{OFDM}) = g_c(t_0+ mT_{OFDM})$, where $g_c = g_{rcos}*q_c*g_{rcos}(nT_c)$, as can be seen in Fig. ~\ref{plot:h}. Finally we convert the parallel of the $A_k[i]$ blocks in their series and trasmit the obtained bit sequence $s_k$ through the channel.
\newline The channel model we have to implement is composed by trasmitter and received filters $g_{rcos}(nT_c)$ whose impulse response is the same and it's reportend in Fig. ~\ref{plot:g_rcos}, and by the channel itself whose impulse response is $q_c$ and it's shown in Fig. ~\ref{plot:qc}. Before the receiver filter we add the complex gaussian noise  
of the channel that we estimate using the information of our target SNR ($\Gamma$) through the relation:

\begin{align*}
\sigma_{\omega}^2 = \frac{(M-N_{vir})}{M^2}\frac{\sigma_{a}^2 E_{g_{rcos},qc}}{\Gamma}
\end{align*}

where $E_{g_{rcos},qc}$ is the energy of the series between the transmitter filter and the channel $g_{rcos,qc}(nT_c) = g_{rcos}*q_c(nT_c)$ and $\sigma_a^2 = 2$ is the power of the transmitted constallation.



\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/qc}
  \caption{Channel impulse response}
  \label{plot:qc}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/g_rcos}
  \caption{Transmitter/receiver filter impulse response}
  \label{plot:g_rcos}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/gc}
  \caption{Global impulse response before receiver sampler}
  \label{plot:gc}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/h}
  \caption{Equivalent channel impulse response}
  \label{plot:h}
\end{figure}


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/qc_freqz}
  \caption{Channel frequency response}
  \label{plot:qc_freqz}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/g_rcos_freqz}
  \caption{Transmitter/receiver filter frequency response}
  \label{plot:g_rcos_freqz}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{matlab/gc_dft}
  \caption{M-sample DFT of the overall response $g_c$}
  \label{plot:gc_dft}
\end{figure}


\end{document}
